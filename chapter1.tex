% !TeX root = document.tex
% !TeX encoding = UTF-8 Unicode

\chapter{Introduction}%
\label{chp:introduction}

Physical systems have constraints on their inputs, outputs, and states, which
are usually ignored to facilitate the controller's design. Such constraints can
result from physical limitations, such as a tank's capacity or a turbine's
maximum power output, or can be mathematically imposed to achieve some goal,
like keeping a process' pH bounded. The most common form of constraint found in
literature is actuator saturation, and many techniques exist to deal with it,
like using a polytopic representation or a generalized sector
condition~\parencite{klug.castelan.ea:fuzzy,tarbouriech.garcia.ea:stability}.
However, those techniques do not enforce constraints but merely design
conservative controllers that avoid the borders of constraints or even allow the
system to violate them for a short period.

By taking advantage of optimization techniques, new solutions to the problem
appeared. Model Predictive Control uses an online optimization procedure to
compute a system's optimal control trajectory and allows constraints to be
applied to states, inputs, outputs, and their
variations~\parencite{wang:model,zhang:fast}. As the optimization procedure is
online, constraints are enforced, and the controller will actively avoid
violations while allowing for less conservative control paths.

Another technique was developed simultaneously, but instead of computing the
optimal control path that keeps the system constrained, it uses model prediction
to change the reference given to existing controllers to keep the system
constrained. The first of such techniques were reference filters, which imposed
only soft-constraints~\parencite{vahidi.kolmanovsky.ea:constraint}, i.e.
constraints which penalize the objective function when violated instead of
rendering the problem infeasible.

Such an idea then evolved into Reference Governors (RG), which uses optimization
to find a virtual reference \(g(k)\), which is as close as possible to the real
reference \(r(k)\) but keeps the system
constrained~\parencite{gilbert.kolmanovsky.ea:discrete‐time}.
Figure~\ref{fig:rg-block-diagram} shows a block diagram for this technique. The
RG gives the controller the virtual reference \(g(k)\), which is a scaled
version of the real reference \(r(k)\), read \(g(k)=\delta{}r(k)\). The optimization
problem finds the best \(\delta\) that minimizes the distance between \(g(k)\) and
\(r(k)\) without violating constraints. Because of the simplicity of the
optimization problem, this approach has an easy implementation but suffers from
loss of dimensions. Such a loss comes from the fact that \(\delta\) is
one-dimensional while \(r(k)\) may be
multidimensional~\parencite{gilbert.kolmanovsky:fast}.

\begin{figure}
  \centering
  \tikzstyle{block}    = [draw, rectangle, minimum height=3em, minimum width=6em]
  \tikzstyle{sum}      = [draw, circle, node distance=1cm]
  \tikzstyle{point}    = [coordinate]
  \tikzstyle{pinstyle} = [pin edge={to-,thin,black}]
  \begin{tikzpicture}[auto, node distance=2cm,>=latex']
    % We start by placing the blocks
    \node [point, name=input] {};
    \node [sum] (prod) [right=4cm of input] {\Large \(\times\)};
    \node [block] (controller) [right=1cm of prod] {Controller};
    \node [block, above of=prod] (rg) {Reference Governor};
    \node [block] (system) [right=1cm of controller] {System};
    \node [point, name=output, node distance=3cm, right of=system] {};
    \node [point, name=state, above of=system] {};
    \node [point, name=ref, left of=rg] {};

    \draw [draw,->] (input) -- node [name=r] {\(r(k)\)} (prod);
    \draw [] (r) |- (ref);
    \draw [->] (ref) -- (rg);
    \draw [->] (rg) -- node {\(\delta\)} (prod);
    \draw [->] (prod) -- node {\(g(k)\)} (controller);
    \draw [->] (controller) -- node {\(u(k)\)} (system);
    \draw [->] (system) -- node {\(y(k)\)} (output);
    \draw [] (system) -- node {\(x(k)\)} (state);
    \draw [->] (state) -- node {} (rg);
  \end{tikzpicture}
  \caption{Reference Governor's block diagram}%
  \label{fig:rg-block-diagram}
\end{figure}

Building on this idea,~\textcite{bemporad.casavola.ea:nonlinear}
and~\textcite{casavola.mosca.ea:robust} developed what is known today as the
\ac{CG} approach. The difference to RG is that the \CG{} technique optimizes the
\(g(k)\) vector directly, requiring more computational processing power but
yielding better system performance since the values of the vector are calculated
independently and freely instead of as a factor of the reference. This approach
also builds on the work of~\textcite{kapasouris.athans.ea:design}, which
explores the ideas of the Lyapunov Theorem and Invariant Sets
Theorem~\parencite{blanchini.miani:set-theoretic}.

Reference and Command Governors are still subjects of studies, and used in
conjunction with other techniques. It has been of particular interest on the
adaptive control field
\parencite{arabi.yucelen.ea:command,ristevski.dogan.ea:transient,wilcher.jaramillo.ea:on,dogan.yucelen.ea:improving,gruenwald.yucelen.ea:expanded,makavita.jayasinghe.ea:experimental}
as a mean to add constraints to the system. It has also been used to constrain
switching networks \parencite{ong.djamari.ea:governor}, networks with delays
\parencite{shen.song.ea:constrained} and interconnected systems
\parencite{tedesco.casavola:turn-based}. \textcite{peng.wang.ea:constrained}
also used a Command Governor to develop an anti-disturbance controller for a
uncertain, constrained system
and~\textcite{schwerdtner.bortoff.ea:projection-based} developed a anti-windup
controller for systems with saturated inputs.
\textcite{seeber.golles.ea:reference} provides a real-time implementation of
reference shaping for a biomass grate boiler, based on Command Governor, to
avoid actuator saturation and constrain mass-flow.

What makes it possible to use the Command Governor in so many different
scenarios is the fact that it is an add-on technique, that does not require
adaptation from the controller or system. On the other hand, different ways of
calculating the virtual reference are explored, since the optimization based
procedure, although the best in guaranteeing hard-constraints, can be very
resource intensive, making it impracticable for systems with fast dynamics. It
remains suitable for systems with slow dynamics and simulations. There is also a
decision to be made on what strategy to follow in the case in which no virtual
reference that satisfies the constraints exists, which can happen if the model
deviates significantly from the real system, for example. A common technique is
to re-apply the last reference, but it can lead to instability if the situation
persists for extended periods of
time~\parencite{garone.di-cairano.ea:reference}.

Switching systems are composed of many subsystems, called modes, which switch
according to a switching
rule~\parencite{liberzon:switching,liberzon.morse:basic}. Only one subsystem can
be active at a given time. The switching can cause instability even when all
subsystems are stable. Techniques exist to guarantee stability under abirtrary
switching, such as using polytopic linear parameter varying
representations~\parencite{deaecto.geromel.ea:robust} , but they are extremely
conservative. Development then lead to the notion of a dwell-time: how long a
subsystem must remain active before switching to avoid
instability~\parencite{liberzon.morse:basic}. Different approaches have been
proposed to compute the minimum dwell time
(see~\parencite{chesi.colaneri.ea:computing} and reference therein) and
stabilizing controller (see~\parencite{lin.antsaklis:stability} for switched
linear systems). Fewer solutions exist to deal with constrained switching
systems, see e.g.~\parencite{franzè.lucia.ea:command,lucia.franzè:stabilization}
and references therein.

In \parencite{franzè.lucia.ea:command,lucia.franzè:stabilization}, the \CG{}
framework is used to supervise the system mode switches and assure both
stability and constraint satisfaction.

\section{Objectives}%
\label{sec:objectives}

In this work, considering the class of constrained switched systems (switching
systems with controlled switching signals), we propose a novel switching rule
based on the controllers's region of attraction. Two rules can be stated:

\begin{enumerate}
  \item the system's state is inside the next controller's region of attraction.
  \item the system's state is inside the command governors' constraint's
        intersection.
\end{enumerate}

This allows for 2 switching rules. In the first scenario, the first rule
triggers a partial switch, in which only the controller is changed. The second
rule is used to complete the switch, swaping the active command governor unit.
We call this a hybrid switch. The second scenario makes a complete switch using
only the second rule. However, everything that needs to be done to guarantee
stability in the first scenario also has to be done in the second scenario. The
only difference is that the second avoids the first set membership check, at the
cost of possibly missing on convergence's speed gains opportunities.

\section{Document organization}%
\label{sec:organization}

The main concepts involved in this work are explained in
Chapter~\ref{chp:theoretical-foundations} -
\nameref{chp:theoretical-foundations}. The proposed technique is explained in
Chapter~\ref{chp:switching-rules} - \nameref{chp:switching-rules}. In
Chapter~\ref{chp:results} - \nameref{chp:results} we show two experiments that
illustrate the advantages of the proposed technique.
