% !TeX root = document.tex
% !TeX encoding = UTF-8 Unicode

\chapter{Introduction}%
\label{chp:introduction}

Physical systems have constraints on their inputs, outputs, and states, which
are usually ignored to facilitate the controller's design. Such constraints can
result from physical limitations, such as a tank's capacity or a turbine's
maximum power output, or can be mathematically imposed to achieve some goal,
like keeping a process' pH bounded. In the literature, different solutions
exists to address actuator saturation constraints, see
e.g.~\parencite{klug.castelan.ea:fuzzy,tarbouriech.garcia.ea:stability}.
However, those techniques do not enforce constraints but design controllers that
avoid the borders of constraints or even allow the system to violate them for a
short period.

By taking advantage of optimization techniques, Model Predictive Control uses an
online optimization procedure to predict a system's state evolution on a
prediction horizon and compute a system's optimal control trajectory and allows
constraints to be imposed to states, inputs, outputs, and their
variations~\parencite{wang:model,zhang:fast}. As the optimization procedure is
online, constraints are enforced, and the controller will actively avoid
violations while allowing for less conservative control paths.

Another technique was developed, but instead of computing the optimal control
path that keeps the system constrained, it uses model prediction to change the
reference given to existing controllers to keep the system constrained. The
first of such techniques were reference filters, which imposed only
soft-constraints~\parencite{vahidi.kolmanovsky.ea:constraint}, i.e. constraints
which penalize the objective function when violated instead of rendering the
problem infeasible.

Such an idea then evolved into Reference Governors (RG), which divides the
problem into two parts: tracking and constraint enforcement. The (possibly
already existing) controller solves the tracking problem in the inner loop
without taking constraints into account, and the Reference Governor solves the
constraint enforcement problem in the outer loop by using the reference and
system's output to change the inner loop's reference.
Figure~\ref{fig:rg-block-diagram} shows a block diagram for this technique. The
optimization problem finds the best \(\delta\) that minimizes the distance between
\(g(k)\) and \(r(k)\) without violating constraints. Because of the numerical
simplicity of the optimization problem, this approach has an easy implementation
but suffers from loss of dimensions. Such a loss comes from the fact that
\(\delta\in\mathcal{R}\) while
\(r(k)\in\mathcal{R}^n\)~\parencite{gilbert.kolmanovsky:fast}.

\begin{figure}
  \centering
  \tikzstyle{block}    = [draw, rectangle, minimum height=3em, minimum width=6em]
  \tikzstyle{sum}      = [draw, circle, node distance=1cm]
  \tikzstyle{point}    = [coordinate]
  \tikzstyle{pinstyle} = [pin edge={to-,thin,black}]
  \begin{tikzpicture}[auto, node distance=2cm,>=latex']
    % We start by placing the blocks
    \node [point, name=input] {};
    \node [sum] (prod) [right=4cm of input] {\Large \(\times\)};
    \node [block] (controller) [right=1cm of prod] {Controller};
    \node [block, above of=prod] (rg) {Reference Governor};
    \node [block] (system) [right=1cm of controller] {System};
    \node [point, name=output, node distance=3cm, right of=system] {};
    \node [point, name=state, above of=system] {};
    \node [point, name=ref, left of=rg] {};

    \draw [draw,->] (input) -- node [name=r] {\(r(k)\)} (prod);
    \draw [] (r) |- (ref);
    \draw [->] (ref) -- (rg);
    \draw [->] (rg) -- node {\(\delta\)} (prod);
    \draw [->] (prod) -- node {\(g(k)\)} (controller);
    \draw [->] (controller) -- node {\(u(k)\)} (system);
    \draw [->] (system) -- node {\(y(k)\)} (output);
    \draw [] (system) -- node {\(x(k)\)} (state);
    \draw [->] (state) -- node {} (rg);
    \draw [->] (state) -| node {} (controller);
  \end{tikzpicture}
  \caption{Reference Governor's block diagram}%
  \label{fig:rg-block-diagram}
\end{figure}

Building on this idea and on the work of~\textcite{kapasouris.athans.ea:design},
which explores the ideas of the Lyapunov Theorem and Invariant Sets
Theorem~\parencite{blanchini.miani:set-theoretic},
\textcite{bemporad.casavola.ea:nonlinear}
and~\textcite{casavola.mosca.ea:robust} developed what is known today as the
\ac{CG} approach. The difference is that Reference Governors optimize a number
\(\delta\), which multiplies the reference \(r(k)\) to create the virtual reference
\(g(k)\), whereas Command Governors optimize the the vector \(g(k)\) directly,
requiring more computational processing power but yielding better closed-loop
performance.

Reference and Command Governors are still subjects of studies, and used in
conjunction with other techniques. It has been of particular interest on the
adaptive control field
\parencite{arabi.yucelen.ea:command,ristevski.dogan.ea:transient,wilcher.jaramillo.ea:on,dogan.yucelen.ea:improving,gruenwald.yucelen.ea:expanded,makavita.jayasinghe.ea:experimental}
as a mean to add constraints to the system. It has also been used to constrain
switching networks \parencite{ong.djamari.ea:governor}, networks with delays
\parencite{shen.song.ea:constrained} and interconnected systems
\parencite{tedesco.casavola:turn-based}. \textcite{peng.wang.ea:constrained}
also used a Command Governor to develop an anti-disturbance controller for a
uncertain, constrained system
and~\textcite{schwerdtner.bortoff.ea:projection-based} developed a anti-windup
controller for systems with saturated inputs.
\textcite{seeber.golles.ea:reference} provides a real-time implementation of
reference shaping for a biomass grate boiler, based on Command Governor, to
avoid actuator saturation and constrain mass-flow.

What makes it possible to use the Command Governor in so many different
scenarios is the fact that it is an add-on technique, that does not require
adaptation from the controller or system. This is one main advantage of the
Command Governor, as well as the fact that it enforces hard-constraints. The
main drawback is that it requires an online optimization procedure, which might
not be doable on systems with fast dynamics. Another concern is that the
optimization problem might not be feasible in the presence of model
uncertainties. A common technique is to re-apply the last reference when the
optimization problem is unfeasible, but it can lead to instability if the
situation persists for extended periods of
time~\parencite{garone.di-cairano.ea:reference}.

Switching systems are composed of many subsystems, called modes, which switch
according to a switching
rule~\parencite{liberzon:switching,liberzon.morse:basic}. Only one subsystem can
be active at a given time. The switching can cause instability even when all
subsystems are stable. Techniques exist to guarantee stability under abirtrary
switching, such as using polytopic linear parameter varying
representations~\parencite{deaecto.geromel.ea:robust} , but they are extremely
conservative. Development then lead to the notion of a dwell-time: how long a
subsystem must remain active before switching to avoid
instability~\parencite{liberzon.morse:basic}. Different approaches have been
proposed to compute the minimum dwell time
(see~\parencite{chesi.colaneri.ea:computing} and reference therein) and
stabilizing controller (see~\parencite{lin.antsaklis:stability} for switched
linear systems). Fewer solutions exist to deal with constrained switching
systems, see e.g.~\parencite{franzè.lucia.ea:command,lucia.franzè:stabilization}
and references therein.

In \parencite{franzè.lucia.ea:command,lucia.franzè:stabilization}, the \CG{}
framework is used to supervise the system mode switches and assure both
stability and constraint satisfaction.

\section{Objectives}%
\label{sec:objectives}

In this work, considering the class of constrained switched systems (switching
systems with controlled switching signals), we propose a novel switching rule
based on the controllers's region of attraction. Two rules can be stated:

\begin{enumerate}
  \item the system's state is inside the next controller's region of attraction.
  \item the system's state is inside the command governors' constraint's
        intersection.
\end{enumerate}

This allows for 2 switching rules. In the first scenario, the first rule
triggers a partial switch, in which only the controller is changed. The second
rule is used to complete the switch, swaping the active command governor unit.
We call this a hybrid switch. The second scenario makes a complete switch using
only the second rule. However, everything that needs to be done to guarantee
stability in the first scenario also has to be done in the second scenario. The
only difference is that the second avoids the first set membership check, at the
cost of possibly missing on convergence's speed gains opportunities.

\section{Thesis organization}%
\label{sec:organization}

The main concepts involved in this work are explained in
Chapter~\ref{chp:theoretical-foundations} -
\nameref{chp:theoretical-foundations}. The proposed technique is explained in
Chapter~\ref{chp:switching-rules} - \nameref{chp:switching-rules}. In
Chapter~\ref{chp:results} - \nameref{chp:results} we show two experiments that
illustrate the advantages of the proposed technique.
